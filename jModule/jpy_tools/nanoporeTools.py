import pyranges as pr
import numpy as np
import pandas as pd
import sh
from typing import (
    Dict,
    List,
    Optional,
    Union,
    Sequence,
    Literal,
    Any,
    Tuple,
    Iterator,
    Mapping,
    Callable,
)


def bedtoolsGetIntersect(
    inBam,
    path_bed,
    path_read=None,
    onlyGene=False,
    strand: Literal["both", "sense", "antisense"] = "both",
    onlyBest=True,
    bedtoolsPath="bedtools",
) -> pd.DataFrame:
    """
    use bedtools get intersect information between bam and bed

    Parameters
    ----------
    inBam :
        bam path
    bedAnno :
        bed path, generated by `gtfToBed12_addGeneName.py`
    path_read : optional
        read path, could be `fa` or `fq`, by default None
    onlyGene : bool, optional
        gene level or trancript level, by default False
    strand : Literal["both", "sense", "antisense"], optional
        by default "both"
    onlyBest : bool, optional
        by default True
    bedtoolsPath : str, optional
        by default "bedtools"

    Returns
    -------
    pd.DataFrame
        [description]
    """
    from tempfile import NamedTemporaryFile
    from io import StringIO
    from .readProcessTools import FastaContent, FastqContent

    fhBed_gene = NamedTemporaryFile("w+t", suffix=".bed")
    bed = pr.read_bed(path_bed, as_df=True)

    if onlyGene:
        bed = bed.loc[bed["Name"].map(lambda x: x.split("|")[0] == x.split("|")[-1])]
        bed["Name"] = bed["Name"].str.split("\|").str[0]
    else:
        bed = bed.loc[bed["Name"].map(lambda x: x.split("|")[0] != x.split("|")[-1])]

    bed.to_csv(fhBed_gene.name, sep="\t", header=None, index=None)

    if strand == "both":
        senseStrandOnly = False
        antisenseStrandOnly = False
    elif strand == "sense":
        senseStrandOnly = True
        antisenseStrandOnly = False
    elif strand == "antisense":
        senseStrandOnly = False
        antisenseStrandOnly = True
    else:
        assert False, f"Unknown `strand` parameter: {strand}"

    if path_read:
        if (path_read.endswith(".fq")) | (path_read.endswith(".fastq")):
            FaContent = FastqContent
        elif (path_read.endswith(".fa")) | (path_read.endswith(".fasta")):
            FaContent = FastaContent
        else:
            assert False, f"Unknown `path_read` format"
        fa = FaContent(path_read, useIndex=True)

    intersectBuff = StringIO()

    sh.Command(bedtoolsPath).intersect(
        abam=inBam,
        b=fhBed_gene.name,
        wo=True,
        s=senseStrandOnly,
        S=antisenseStrandOnly,
        split=True,
        bed=True,
        _out=intersectBuff,
        _long_prefix="-",
        _long_sep=" ",
    )
    intersectBuff.seek(0)

    NAMES = [
        "Chromosome",
        "Start",
        "End",
        "Name",
        "Score",
        "Strand",
        "ThickStart",
        "ThickEnd",
        "ItemRGB",
        "BlockCount",
        "BlockSizes",
        "BlockStarts",
        "geneChromosome",
        "geneStart",
        "geneEnd",
        "geneName",
        "geneScore",
        "geneStrand",
        "geneThickStart",
        "geneThickEnd",
        "geneItemRGB",
        "geneBlockCount",
        "geneBlockSizes",
        "geneBlockStarts",
        "cov",
    ]
    USECOLS = [
        "Chromosome",
        "Start",
        "End",
        "Name",
        "Strand",
        "geneStart",
        "geneEnd",
        "geneName",
        "geneStrand",
        "geneBlockSizes",
        "geneBlockStarts",
        "cov",
    ]
    df = pd.read_csv(intersectBuff, sep="\t", names=NAMES, usecols=USECOLS, header=None)
    df["mapStrand"] = np.where(df["Strand"] == df["geneStrand"], "sense", "antisense")
    if onlyBest:
        df = df.sort_values("cov", ascending=False).drop_duplicates(subset=["Name"])

    if path_read:
        df["readLength"] = df["Name"].map(lambda x: len(fa[x].seq))

    fhBed_gene.close()
    return df